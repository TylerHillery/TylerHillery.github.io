{
  "hash": "ccac394a4f18ba59e57cc0af1b1712d8",
  "result": {
    "markdown": "---\ntitle: Effective Python\ndescription: 'My notes on [Effective Python](https://a.co/d/49i4S3a) by Brett Slatkin'\nauthor: Tyler Hillery\ndate: '2024-01-08'\nimage: ./effective_python.jpg\nfilters:\n  - social-share\nshare:\n  permalink: 'https://tylerhillery.com/notes/effective-python/'\n  description: null\n  twitter: true\n  facebook: false\n  reddit: true\n  stumble: false\n  tumblr: false\n  linkedin: true\n  email: true\n  mastodon: true\ncategories:\n  - Technical Books\n  - On Hold\nexecute:\n  echo: true\n  error: true\n---\n\n------------------------------------------------------------------------\n\n# Preface\n\n- Love the start of this book.\n\n  > This book provides insight into the *Pythonic* way of writing programs: the best way to use python. It builds on a fundamental understanding of the language that I assume you already have. Novice programmers will learn the best practices of Python's capabilities. Experienced programmers will learn how to embrace the strangeness of a new tool with confidence\n  \n# Chapter 1. Pythonic Thinking\n\n- PEP 8 is commonly referred to the style guide for how to format Python code. I personally like use the [Ruff Formatter](https://docs.astral.sh/ruff/formatter/) so I don't have to worry about if I am properly formatting my code\n\n- You don't need to explicitly test if a container data type length is 0 or > than 1 when using in an `if` statement because an empty container with result in `False` and a container with a length > 0 will result in `True`\n\n- `bytes` contains sequences of 8-bit values, and `str` contains sequences of Unicode code points.\n\n- Why go through the trouble of assigning the default value for the `.get()` to `['']` instead of 0?\n\n\n  ::: {.cell execution_count=1}\n  ``` {.python .cell-code}\n  from urllib.parse import parse_qs \n  \n  my_values = parse_qs(\"red=5&blue=0&green=\",keep_blank_values=True)\n  print(my_values)\n  green = my_values.get(\"green\", [''])[0] or 0\n  green_my_way = my_values.get(\"green\", 0)\n  print(f\"Green: {green!r}\")\n  print(f\"Green: {green_my_way!r}\")\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  {'red': ['5'], 'blue': ['0'], 'green': ['']}\n  Green: 0\n  Green: ['']\n  ```\n  :::\n  :::\n  \n  \n  Ah I see, it appears the default return value for `parse_qs` if there is no value for the color is a list with an empty string. So that's why we index into the list and if it's `''` which also means `False` we can use the `or 0` to default it to 0 \n\n- Make use of helper functions in Python. Here is an example of how to solve the above problem with a helper function\n\n\n  ::: {.cell execution_count=2}\n  ``` {.python .cell-code}\n  def get_first_int(values, key, default=0):\n    found = values.get(key, [''])\n  \n    if found[0]:\n      return int(found[0])\n    return default\n  \n  green = get_first_int(my_values, \"green\")\n  \n  print(green)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  0\n  ```\n  :::\n  :::\n  \n  \n- You can use unpacking to swap variables in place without need to create temp variables\n\n\n  ::: {.cell execution_count=3}\n  ``` {.python .cell-code}\n  def temp_bubble_sort(a):\n    for _ in range(len(a)):\n      for i in range(1, len(a)):\n        if a[i] < a[i-1]:\n          temp = a[i]\n          a[i] = a[i-1]\n          a[i-1] = temp\n      \n  def inplace_bubble_sort(a):\n    for _ in range(len(a)):\n      for i in range(1, len(a)):\n        if a[i] < a[i-1]:\n          a[i-1], a[i] = a[i], a[i-1] \n  \n  names1 = [\"pretzels\", \"carrots\", \"arugula\", \"bacon\"]\n  names2 = [\"pretzels\", \"carrots\", \"arugula\", \"bacon\"]\n  \n  temp_bubble_sort(names1)\n  inplace_bubble_sort(names2)\n  print(names1)\n  print(names2)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  ['arugula', 'bacon', 'carrots', 'pretzels']\n  ['arugula', 'bacon', 'carrots', 'pretzels']\n  ```\n  :::\n  :::\n  \n  \n- \n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}