{
  "hash": "6579d0331b32562338502bd4ad068926",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Effective Python\ndescription: 'My notes on [Effective Python](https://a.co/d/49i4S3a) by Brett Slatkin'\nauthor: Tyler Hillery\ndate: '2024-05-12'\nimage: ./effective_python.jpg\nfilters:\n  - social-share\nshare:\n  permalink: 'https://tylerhillery.com/notes/effective-python/'\n  description: null\n  twitter: true\n  facebook: false\n  reddit: true\n  stumble: false\n  tumblr: false\n  linkedin: true\n  email: true\n  mastodon: true\ncategories:\n  - Technical Books\nexecute:\n  echo: true\n  error: true\n---\n\n------------------------------------------------------------------------\n\n# Preface\n\n-   Love the start of this book.\n\n    > This book provides insight into the *Pythonic* way of writing programs: the best way to use python. It builds on a fundamental understanding of the language that I assume you already have. Novice programmers will learn the best practices of Python's capabilities. Experienced programmers will learn how to embrace the strangeness of a new tool with confidence\n\n# Chapter 1. Pythonic Thinking\n\n-   PEP 8 is commonly referred to the style guide for how to format Python code. I personally like use the [Ruff Formatter](https://docs.astral.sh/ruff/formatter/) so I don't have to worry about if I am properly formatting my code\n\n-   You don't need to explicitly test if a container data type length is 0 or \\> than 1 when using in an `if` statement because an empty container with result in `False` and a container with a length \\> 0 will result in `True`\n\n-   `bytes` contains sequences of 8-bit values, and `str` contains sequences of Unicode code points.\n\n-   Why go through the trouble of assigning the default value for the `.get()` to `['']` instead of 0?\n\n\n    ::: {#4d838722 .cell execution_count=1}\n    ``` {.python .cell-code}\n    from urllib.parse import parse_qs \n    \n    my_values = parse_qs(\"red=5&blue=0&green=\",keep_blank_values=True)\n    print(my_values)\n    green = my_values.get(\"green\", [''])[0] or 0\n    green_my_way = my_values.get(\"green\", 0)\n    print(f\"Green: {green!r}\")\n    print(f\"Green: {green_my_way!r}\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    {'red': ['5'], 'blue': ['0'], 'green': ['']}\n    Green: 0\n    Green: ['']\n    ```\n    :::\n    :::\n    \n    \n    Ah I see, it appears the default return value for `parse_qs` if there is no value for the color is a list with an empty string. So that's why we index into the list and if it's `''` which also means `False` we can use the `or 0` to default it to 0\n\n-   Make use of helper functions in Python. Here is an example of how to solve the above problem with a helper function\n\n\n    ::: {#f4a3fb91 .cell execution_count=2}\n    ``` {.python .cell-code}\n    def get_first_int(values, key, default=0):\n      found = values.get(key, [''])\n    \n      if found[0]:\n        return int(found[0])\n      return default\n    \n    green = get_first_int(my_values, \"green\")\n    \n    print(green)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    0\n    ```\n    :::\n    :::\n    \n    \n-   You can use unpacking to swap variables in place without need to create temp variables\n\n\n    ::: {#28cdcc52 .cell execution_count=3}\n    ``` {.python .cell-code}\n    def temp_bubble_sort(a):\n      for _ in range(len(a)):\n        for i in range(1, len(a)):\n          if a[i] < a[i-1]:\n            temp = a[i]\n            a[i] = a[i-1]\n            a[i-1] = temp\n        \n    def inplace_bubble_sort(a):\n      for _ in range(len(a)):\n        for i in range(1, len(a)):\n          if a[i] < a[i-1]:\n            a[i-1], a[i] = a[i], a[i-1] \n    \n    names1 = [\"pretzels\", \"carrots\", \"arugula\", \"bacon\"]\n    names2 = [\"pretzels\", \"carrots\", \"arugula\", \"bacon\"]\n    \n    temp_bubble_sort(names1)\n    inplace_bubble_sort(names2)\n    print(names1)\n    print(names2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    ['arugula', 'bacon', 'carrots', 'pretzels']\n    ['arugula', 'bacon', 'carrots', 'pretzels']\n    ```\n    :::\n    :::\n    \n    \n# Starting Over\n\nI starting from the beginning of this book again it's been awhile since I put the the book down. \n\n# Chapter 1. Pythonic Thinking\n\n- `isinstance` function allows you to compare variable to a specific type and will return True or False\n- When working with bytes and strings make sure to convert them to the same type because they don't work well with each other. For example you can't add bytes to string and you can't compare them\n- All things talk about bytes and strings must of been caused by the Python 2 to Python 3 migration because I rarely have to use bytes for anything.\n- Interesting I could use this parse_qs for my Harlequin ADBC parameter to help parse some of the optional kwargs that the user can enter\n\n\n  ::: {#c9c611b2 .cell execution_count=4}\n  ``` {.python .cell-code}\n  from urllib.parse import parse_qs\n  \n  my_values = parse_qs(\"red=5&blue=0&green=\", keep_blank_values=True)\n  \n  print(my_values)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  {'red': ['5'], 'blue': ['0'], 'green': ['']}\n  ```\n  :::\n  :::\n  \n  \n- I know I wrote about it the first time but I think the inplace swap with unpacking is so clean in python. Eliminates the need of a temporary variable. The bubble sort algorithm is a great example of when you would use something like this.\n- When iterating ove a list and you also want access to the index use the `enumerate` function\n- > `zip` consumes the iterators it wraps one time at a time, which means it can be used with infinitely long inputs without risk of a program using too much memory and crashing\n- `zips` output is as long as the shortest input, you can use the `itertools.zip_longest()` instead if you want to go the longest input\n\n# Chapter 2. Lists and Dictionaries\n\n- The `dict` type is often called an *associative array* or a *hash table*\n- Using the `key` parameter to sort a list\n\n\n  ::: {#c6bd016a .cell execution_count=5}\n  ``` {.python .cell-code}\n  class Tool:\n      def __init__(self, name, weight):\n          self.name = name\n          self.weight = weight\n  \n      def __repr__(self):\n          return f\"Tool({self.name!r}, {self.weight})\"\n      \n  tools = [\n      Tool(\"level\", 3.5),\n      Tool(\"hammer\", 1.25),\n      Tool(\"screwdriver\", 0.5),\n      Tool(\"ruler\", 0.25),\n      Tool(\"chisel\", 0.25),\n  ]\n  \n  tools.sort(key=lambda x: x.weight, reverse=True)\n  \n  print(tools)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  [Tool('level', 3.5), Tool('hammer', 1.25), Tool('screwdriver', 0.5), Tool('ruler', 0.25), Tool('chisel', 0.25)]\n  ```\n  :::\n  :::\n  \n  \n- Interesting to hear that the `tuple` type are comparable by default with natural ordering\n\n\n  ::: {#32b7bae7 .cell execution_count=6}\n  ``` {.python .cell-code}\n  tools.sort(key=lambda x: (-x.weight, x.name))\n  print(tools)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  [Tool('level', 3.5), Tool('hammer', 1.25), Tool('screwdriver', 0.5), Tool('chisel', 0.25), Tool('ruler', 0.25)]\n  ```\n  :::\n  :::\n  \n  \n- Python provides a *stable* sorting algorithm so when you first sort on something and then sort on another thing. If there is a tie in the second sort it will preserve the order from the first sort. You just need to execute the sorts in the opposite sequence of what you want the final `list` to contain. \n- I don't understand how `votes.get` works here with out the use of a `lambda` function\n\n\n  ::: {#a62663f6 .cell execution_count=7}\n  ``` {.python .cell-code}\n  votes = {\n    \"otter\": 1281,\n    \"polar bear\": 587,\n    \"fox\": 863,\n  }\n  \n  names = list(votes.keys())\n  print(names)\n  \n  names.sort(key=votes.get, reverse=False)\n  print(names)\n  \n  # I would have thought that you would have to do this\n  names.sort(key=lambda x: votes.get(x,0), reverse=True)\n  print(names)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  ['otter', 'polar bear', 'fox']\n  ['polar bear', 'fox', 'otter']\n  ['otter', 'fox', 'polar bear']\n  ```\n  :::\n  :::\n  \n  \n  It appears key automatically applies any function to all elements in the list so in a way I should think of key kind of like a mapping function where I can specify any function to be applied to all elements in the list that return a scalar value that I want to sort on\n\n- I am not familiar with this `iter` function\n\n\n  ::: {#97035ba3 .cell execution_count=8}\n  ``` {.python .cell-code}\n  ranks = {}\n  for i, name in enumerate(names, 1):\n    ranks[name] = i\n  \n  print(ranks)\n  \n  print(next(iter(ranks)))\n  # I would have done something like this, so good to know about next(iter())\n  print(list(ranks.keys())[0])\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  {'otter': 1, 'fox': 2, 'polar bear': 3}\n  otter\n  otter\n  ```\n  :::\n  :::\n  \n  \n  Okay I get it now, so essentially this is an easier way to iterate over the keys in a dict since we don't want to iterate over all the items we can create and iter object and call next on it. IIRC, this is what `for in` does under the hood. My method would have been to turn rank.keys() into list and subscript first element. This is a a little more verbose and has the done sides have having to store the whole list of keys in memory whereas I think the iter(ranks) is lazily evaluated.\n\n- Not sure if I follow why the `SortedDict` Class is returning the wrong value when calling the get winner\n\n\n  ::: {#d4226ee7 .cell execution_count=9}\n  ``` {.python .cell-code}\n  from collections.abc import MutableMapping\n  \n  class SortedDict(MutableMapping):\n    def __init__(self):\n      self.data = {}\n    \n    def __getitem__(self, key):\n      return self.data[key]\n    \n    def __setitem__(self, key, value):\n      self.data[key] = value\n    \n    def __delitem__(self, key):\n      del self.data[key]\n    \n    def __iter__(self):\n      keys = list(self.data.keys())\n      keys.sort()\n      for key in keys:\n        yield key\n      \n    def __len__(self):\n      return len(self.data)\n  \n  def populate_ranks(votes, ranks):\n    names = list(votes.keys())\n    names.sort(key=votes.get, reverse=True)\n    for i, name in enumerate(names, 1):\n      ranks[name] = i\n  \n  def get_winner(ranks):\n    return next(iter(ranks)) \n  \n  regular_ranks = {}\n  sorted_ranks = SortedDict()\n  populate_ranks(votes, regular_ranks)\n  populate_ranks(votes, sorted_ranks)\n  print(regular_ranks)\n  print(sorted_ranks.data)\n  regular_winner = get_winner(regular_ranks)\n  sorted_winner = get_winner(sorted_ranks)\n  print(regular_winner)\n  \n  # returns the first alphabetic result because of we implemented __iter__\n  print(sorted_winner)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  {'otter': 1, 'fox': 2, 'polar bear': 3}\n  {'otter': 1, 'fox': 2, 'polar bear': 3}\n  otter\n  fox\n  ```\n  :::\n  :::\n  \n  \n    I understand now, the winner results wasn't being return properly because in this new `SortedDict` class we implemented the `__iter__` to sort the keys alphabetically\n\n- the `setdefault` method is very handy and I always forget about it\n\n\n  ::: {#77630f14 .cell execution_count=10}\n  ``` {.python .cell-code}\n  votes = {\n    \"baguette\": [\"Bob\", \"Alice\"],\n    \"ciabatta\": [\"Coco\", \"Deb\"],\n  }\n  \n  key = \"brioche\"\n  who = \"Elmer\"\n  \n  names = votes.setdefault(key, [])\n  names.append(who)\n  \n  print(votes)\n  \n  # another way to do it (preferred by author)\n  key = \"wheat\"\n  who = \"Tyler\"\n  \n  if (names := votes.get(key)) is None:\n    # never seen this triple assignment first\n    votes[key] = names = []\n  \n  names.append(who)\n  \n  print(votes)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  {'baguette': ['Bob', 'Alice'], 'ciabatta': ['Coco', 'Deb'], 'brioche': ['Elmer']}\n  {'baguette': ['Bob', 'Alice'], 'ciabatta': ['Coco', 'Deb'], 'brioche': ['Elmer'], 'wheat': ['Tyler']}\n  ```\n  :::\n  :::\n  \n  \n  Interesting, after reading further on the Author other actually discourages the use of `setdefault` because it hurts readability\n\n  > the default value passed to `setdefault` is assigned directly into the dictionary when the key is missing instead of being copied...This means that you need to make sure that you are always constructing a new default value for each key I access with `setdefault`. This leads to significant performance overhead in this example because I have to allocate a `list` instance for each call.\n\n  I am not sure I follow here. This is making more confused and now I am starting to wonder why I need `setdefault` when I could always use `get` and pass in a default value when the key doesn't exists?\n\n  Also I don't get the `get` method in the counter example only requires one access and one assignment while the `setdefault requires one access and two assignments? Does the default value always get assigned no matter what?\n\n  ```python\n  # get\n  count = counters.get(key, 0)\n  counters[key] = count + 1\n\n  # setdefault\n  count = counters.setdefault(key, 0)\n  counters[key] = count + 1\n  ```\n\n  The author states is best to only use the `setdefault` when the default values are cheap to construct, mutable and there's no potential for raising exceptions. In most cases it's better to use the `defaultdict` over the `setdefault` \n\n- Here is a good example of using `defaultdict`\n\n\n  ::: {#76dea696 .cell execution_count=11}\n  ``` {.python .cell-code}\n  from collections import defaultdict\n  \n  class Visits:\n    def __init__(self):\n      self.data = defaultdict(set)\n  \n    def add(self, country, city):\n      self.data[country].add(city)\n  \n  visits = Visits()\n  \n  visits.add(\"England\", \"Bath\")\n  visits.add(\"England\", \"London\")\n  visits.add(\"England\", \"Bath\")\n  print(visits.data)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  defaultdict(<class 'set'>, {'England': {'Bath', 'London'}})\n  ```\n  :::\n  :::\n  \n  \n- The `__missing__` dunder method can be helpful when you can't use `setdefault` because it always creates the default object regardless if the key is already present which can be problematic and you can't use `defaultdict`  because you can't pass in a parameter into the function reference.\n\n  ```python\n  pictures = {}\n  path = \"profile.png\"\n\n  # setdefault method (doesn't work)\n  try:\n    # open function always gets called here even when path is\n    # already present in the dictionary. This results in an\n    # additional file handle that may conflict with existing\n    # open handles in the same program\n    handle = pictures.setdefault(path, open(path, \"a+b\"))\n  except OSError:\n    print(f\"Failed to open path {path}\")\n    raise\n  else:\n    handle.seek(0)\n    image_data = handle_read()\n\n  # defaultdict method\n  from collections import defaultdict\n\n  def open_picture(profile_path):\n    try:\n      return open(profile_path, \"a+b\")\n    except OSError:\n      print(f\"Failed to open path {path}\")\n      raise\n  \n  # will error out because open_picture func ref requires\n  # argument profile_picture\n  pictures = defaultdict(open_picture)\n  handle = pictures[path]\n  handle.seek(0)\n  image_data = handle.read()\n\n\n  # __missing__\n  class Pictures(dict):\n    def __missing__(self, key):\n      value = open_picture(key)\n      self[key] = value\n      return value\n  \n  pictures = Pictures()\n  handle = pictures[path]\n  handle.seek(0)\n  image_data = handle.read()\n  ```\n\n# Chapter 3. Functions\n\n- I finally know what `closures` are, functions that refer to variables from the scope in why there were defined. In the below example this is why the `helper` function is able to access the `group` argument for `sort_priority`\n\n\n  ::: {#3aea5d6c .cell execution_count=12}\n  ``` {.python .cell-code}\n  def sort_priority(values, group):\n    def helper(x):\n      # here I am inside the helper function and yet I can\n      # reference group without having to pass it in as an\n      # argument to the helper function\n      if x in group:\n        return (0, x)\n      return (1, x)\n    values.sort(key=helper)\n  \n  numbers = [8,3,1,2,5,4,7,6]\n  group = {2,3,5,7}\n  sort_priority(numbers, group)\n  print(numbers)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  [2, 3, 5, 7, 1, 4, 6, 8]\n  ```\n  :::\n  :::\n  \n  \n- When someone says Functions are *first-class* objects in Python it means you can do the following\n  - Refer to them directly\n  - Assign them to variables\n  - pass them as arguments to other functions\n  - compare them in expressions and `if` statements\n\n- When comparing sequences in python if first compares the items as index zero and keeps moving on to each sequence if there are equal. This is why the `(0, x)` and `(1, x)` creates two distinct groups\n- One thing I not a big fan of is how this function modifies the original object. I always thought that was an anti-patter. Shouldn't we instead prefer creating a copy instead and return the sorted list?\n- Being careful with *scoping bugs*, python has a specific order when it goes through when referencing a variable before you hit the `NameError`. Assignments work different in closures then referring to a variable directly. Use the `nonlocal` variable to assign data outside the closure.\n- When looking to extend a functions capabilities look at using a key word argument with a default to maintain backwards capability to existing callers.\n\n- ::: callout-caution\n  A default argument value is evaluated once per module load, which usually happens when a program starts. This trips people up a lot so you have to be careful with the default values you provide kwargs. Instead use the default value of `None` and add a conditional `if` to check if `is None` then call assign the default value.\n\n  Especially important for default arguments are mutual e.g. a `list` or it's a function e.g. `datetime.now()`\n  :::\n\n- To define *key-word only* arguments you can force the caller to make the spell out the key word by adding a `*` to indicate the end of all the positional arguments and the beginning of the keyword arguments. \n- Very interesting, I have heard of *key-word only* arguments but this is the first time of hearing *positional-only arguments* where arguments can only be supplied by their position. The `/` indicates where the positional-only arguments ends.\n- Python *decorators* has the ability to run additional code before and after each call to a function it wraps. \n\n# Chapter 4. Comprehensions and Generators\n\n- I was not aware of *generator expressions*, which are like list comprehensions for generators\n- You have to be caution when using generators as they are stateful so if you iterator over an entire generator it's done. It's best way to prevent this if you want to create a function that requires iteratoring over a generator multiple times is to provide a new container class that implements the *iterator protocol* by implementing the `__iter__` method as a generator.\n- I'll be honest I having a hard time understanding some of this more advanced generator topics 😅\n\n# Chapter 5. Classes and Interfaces\n\n- I need understood why I would use a named tuple over a dict. I guess if you want to keep it immutable?\n\n\n  ::: {#8f648bf1 .cell execution_count=13}\n  ``` {.python .cell-code}\n  from collections import namedtuple\n  \n  Grade = namedtuple(\"Grade\", (\"score\", \"weight\"))\n  my_grade = Grade(90,20)\n  print(my_grade.score)\n  \n  grade = {\"score\": 100, \"weight\": 20}\n  print(grade[\"score\"]) \n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  90\n  100\n  ```\n  :::\n  :::\n  \n  \n- I am not sure if I am completely grokking what *polymorphism* is? My mental model as right now is that it enables a class to inherit a method from a parent class but change the functionality of that method. Unsure if that's the right way to think about it.\n- *mix-in* is a class that defines only a small set of additional methods for its child classes to provide.\n- If you defining your own class that you want to behave similar to a container type in Python but you don't want to inherit from that class you can use the `collections.abc` module which stands for *Abstract Base Class*. This will provided errors if you don't implement all the necessary methods and attributes that the abc you are inheriting from expects. Creating your own abc is a common technique for when you want others to adhere to building a class with the same methods and attributes (e.g. Harlequin DatabaseAdapter uses and abc to make sure other adapter authors implement the adapter correctly) \n\n# Chapter 6. Metaclasses and Attributes\n\n- *Descriptor protocol* defines how attribute access is interpreted by the language.\n- Not many notes in this chapter simply because much of it went over my head. I am starting to feel a little detached from the book and having a hard time imagining how I can use some of these tips in my day to day work.\n\n# Chapter 7. Concurrency and Parallelism\n\n- *Concurrency* enables a compute to do many different things *seemingly* at the same time\n- *Parallelism* involves *actually* doing many different things at the same time\n- The key difference between *concurrency* and *parallelism* is *speedup*. \n  - When two distinct paths of execution in a program make forward progress in parallel, the time it takes to do the total work is cut in half; the speed of execution is faster by a fact of two\n  - Concurrent programs may run thousands of separate paths of execution seemingly in parallel but provide no speed for the total work\n- > The standard implementation of python is called CPython. CPython runs a Python program into two steps. First, it parses and compiles the source text into `bytecode`, which is low-level representation of the program as 8-bit instructions...The, CPython runs the bytecode using a stack-based interpreter. The bytecode interpreter has state that must be maintained and coherent while the Python program executes. CPython enforces coherence with a mechanism called *global interpreter lock* (GIL).\n  >\n  > Essentially, the GIL is a mutual-exclusion lock (mutex) that prevents CPython from being affected by preemptive multithreading where one takes control of a program by interrupting another thread. Such an interruption could corrupt interpreter state (e.g. garbage collection reference counts). \n  >\n  > The GIL has an important negative side effect. With programs written in languages like C++ or Java, having multiple threads of execution means that a program could utilize multiple CPU cores at the same time. Although Python supports multiple threads of execution, the GIL causes only one of them to ever make forward progress at a time. This means that when you reach for threads to do parallel computation and speed up your Python programs, you will be sorely disappointed.\n- Why does python support threads at all if it has the GIL?\n  - Makes it easy to for a program to seem like it's doing multiple things at the same time.\n  - To do deal with blocking I/O, which happens when Python does certain types of system calls. Examples include reading/writing files, interacting with networks, communicating with devices like displays etc.\n- *Fan-out* is the process of spawning a concurrent line of execution for each unit of work (generating new units of concurrency)\n- *Fan-in* is the process of waiting for all of those concurrent units of work to finish before moving on to the next phase in a coordinated process (waiting for existing units of concurrency to complete)\n\n# Chapter 8. Robustness and Performance\n\n- Because of how python represents floating point numbers as IEEE 754 that can lead to interesting results\n\n\n  ::: {#13fb2d69 .cell execution_count=14}\n  ``` {.python .cell-code}\n  rate = 1.45\n  seconds = 3*60 + 42\n  cost = rate * seconds / 60\n  print(cost)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  5.364999999999999\n  ```\n  :::\n  :::\n  \n  \n  It's better to the `Decimal` class when you want extreme precision which provides fixed point math of 28 decimal places by default.\n\n\n  ::: {#8b6fdcb7 .cell execution_count=15}\n  ``` {.python .cell-code}\n  from decimal import Decimal\n  \n  rate = Decimal(\"1.45\")\n  seconds = Decimal(3*60 + 42)\n  cost = rate * seconds / Decimal(60)\n  print(cost)\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  5.365\n  ```\n  :::\n  :::\n  \n  \n# Chapter 9. Testing and Debugging\n\n- When debugging or logging make sure to use the `repr` version of an object so you can tell the differences between types e.g. `'5'` or `5`. \n- When using f strings you can use `!r` to get the `repr` version\n\n# Chapter 10. Collaboration\n\nNo notes\n\n# Review\n\nI was shocked to learn about much there really is to Python. I considered myself to be an intermediate python programmer but after reading this book I realized I have plenty to learn. I can confidently recommend this book to anyone looking to improve their python knowledge. I envision myself rereading this book again in the future.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}