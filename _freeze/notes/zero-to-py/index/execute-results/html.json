{
  "hash": "0679403fac02dbea98ca8673893286ec",
  "result": {
    "markdown": "---\ntitle: Zero to Py\ndescription: 'My notes on [Zero to Py](https://leanpub.com/zero-to-py) by Michael Green.'\nauthor: Tyler Hillery\ndate: '2023-12-14'\nimage: ./zero_to_py.png\nfilters:\n  - social-share\nshare:\n  permalink: 'https://tylerhillery.com/notes/zero-to-py/'\n  description: null\n  twitter: true\n  facebook: false\n  reddit: true\n  stumble: false\n  tumblr: false\n  linkedin: true\n  email: true\n  mastodon: true\ncategories:\n  - Technical Books\nexecute:\n  echo: true\n  error: true\n---\n\n------------------------------------------------------------------------\n\n# Part 1: A Whirlwind Tour\n\n## Chapter 0: System Setup\n\nSkipping this section as I have a working instance of python install and feel comfortable using it.\n\n## Chapter 1: Fundamental Data Types\n\n### Variables\n\nTo reference a given value in python you do so by assigning values to variables using the ***assignment operator =***. Variables are references to values and the data type of the var is the determined by the value it is assigned to.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nx = \"Hello World!\"\nprint(x)\nprint(type(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\n<class 'str'>\n```\n:::\n:::\n\n\n#### Variable Naming Rules\n- Can only contain letters, numbers and underscores no specials characters such\nas `!, @, #, $`\n- Must begin with a letter or underscore \n- Names are case-sensitive so `x` is different than `X`\n- Python has some reserved words that cannot be used for names such as `False`,\n`True`, `None` \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# get the full list of reserved key words \nprint(__import__(\"keyword\").kwlist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n:::\n:::\n\n\nIn python there is no concept of *constants* meaning that variables can be reassigned\nwhenever changing the value they reference. A common naming convention for vars\nthat are suppose to be constant is to name the var in all caps `PI = 3.14`\n  \n> ***Strongly Typed Language***: Operations which you can do on variables are \ndependent on the variable's type. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nx = list()\ny = int()\nx + y\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: can only concatenate list (not \"int\") to list\n```\n:::\n:::\n\n\n> ***Primitive Data Types***: also referred to as scalar data types, represent\na single value and are indivisible. Examples include `bool`, `int`, `float`.\n\n> ***Container Data Types***: also known as non-scalar data types, represent\nmultiple values, and are divisible. Examples include `list`, `tuple`, `set`, `dict`.\n\n`str` is a special data type that has properties of both primitive and container\ndata types. \n\n> ***Mutability***: refers to the ability to be able to modify the value after \nthey are created. \n\nFor example, a `list` in python is a mutable data type where you add, remove or\nchange elements in a list after it is created. On the other hand a `tuple` is an\n***immutable*** data type, so you cannot modify anything about it after it is created.\n\n`tuple` immutable ordered collection of items `(1, 2, 3)`\n\n`list` mutable order collection of items `[1, 2, 3]` \n\n`set` mutable unordered collection of unique items `{1, 2, 3}`. You can use `frozenset(my_set)`\nto create a immutable set. \n\n### Objects\n\nEverything in python is an object, which means that each element in the language\nis an ***instance*** of a specific ***class**. This includes built in data types\nsuch as `str`, `int`, `list`. \n\n> When a variable is assigned a value in Python, that value is a reference to an\nobject in memory. This reason for this is because the standard implementation of\nPython is built in C-based infrastructure, where the basic unit of memory that\nholds the value of a python object is a C structure called a `PyObject*`. This \n`struct` contains information about the object's type, its reference count, and\nthe actual value. `PyObject*` is a pointer to `PyObject` and it can be used as an \nopaque handle to the python object, allowing the implementation to abstract the\ndetails of these objects and providing python developers a consistent way to\ninteract with any kind of python object, regardless of its type. \n\nEach object in python has its own unique id assigned to it when created. You can\nuse the built in id() function to find out what the id is for a particular object\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nx = 42\ny = 42 \nprint(id(x))\nprint(id(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n140228581131792\n140228581131792\n```\n:::\n:::\n\n\nThis is interesting, I thought these two values would have the same id. I then \nread the next paragraph which calls out specific values in Python that are\n***singletons*** meaning there will only ever be a single instance of this object.\nThe integers `-5` through `256` are singletons along with `None`, `True`, `False`.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nx = 257\ny = 257\nprint(id(x))\nprint(id(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n140228468623216\n140228468621712\n```\n:::\n:::\n\n\n#### References to Objects\nIn python, variables are references to objects meaning when you create a \nvariable and assign a value to it, the variable does not store the value directly,\ninstead stores a reference to the object that contains that value. It is important\nto note when working with immutable data types if you assign the value through a\nsecond variable both variables reference the same mutable object in memory. \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nx = 257\ny = x\nx = 300\nprint(x)\nprint(y)\n\nx = {}\ny = x \ny[\"fizz\"] = \"buzz\"\nprint(x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n300\n257\n{'fizz': 'buzz'}\n{'fizz': 'buzz'}\n```\n:::\n:::\n\n\n## Chapter 2: Operators\n>***Operators***: Special symbols in Python that carry out various operations.\n\n>***Operand***: The value a given operator operates on. For example: `4 + 5 = 9`\n`4` and `5` would be the operands.\n\nPython supports various types of operators: arithmetic, assignment, comparison,\nlogical, membership, bitwise, and identity.\n\n### Arithmetic \n- Used to perform mathematical operations. \n- The order of these operators follow the same rules in math PEMDAS.\n  - It is recommended though to use parentheses to make the code more readable.\n\nThe most common arithmetic operators:\n\n- `+`  addition \n- `-`  subtraction \n- `*`  multiplication\n- `/`  division\n- `//` floor division\n- `%`  modulation \n- `**` exponentiation  \n\n- Python unpacking operators unpack a sequence into multiple arguments\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nmy_tuple = (1,2)\n\nprint([0, *my_tuple, 3, 4])\n\ndict_one = {\"fizz\": \"buzz\"}\ndict_two = {\"foo\": \"bar\"}\nprint({**dict_one, **dict_two})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2, 3, 4]\n{'fizz': 'buzz', 'foo': 'bar'}\n```\n:::\n:::\n\n\n- Falsy objects: `False`, `None`, `0`, `0.0`, Empty collections i.e. `[]`, `()`,\n`{}`, `set()`\n\n- The identity operator is used to compare the memory address of two objects to\ndetermine if they are same object or not:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nx = 42\ny = 42 \nprint(x is y)\n\nx = 500\ny = 500\nprint(x is y)\n\ny = x\nprint(x is y)\n\nx = [1,2,3]\ny = [1,2,3]\nprint(x is y) # better to use == to see they contain the same values\n\ny = x \nprint(x is y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nTrue\nFalse\nTrue\n```\n:::\n:::\n\n\n## Chapter 3: Lexical Structure \n> ***Lexical Structure***: The smallest units of code that the language is made\nup of, and the rules for combining these units into larger structures. In other\nwords, it is the set of rules that define the syntax and grammar of the language\nand they determine how programs written by developers will be interpreted.\n\n### Line Structure\n- Each logic line is represented by a `NEWLINE` token.\n- A logical line is created by combining one or more \"physical\" lines (the lines\nin a file you create by hitting the \"enter\" key.)\n- Two or more physical lines in python can be joined into a single logical line\nusing the backslash character `\\`\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ngreeting =  \"Hello \" \\\n            \"World\"\nprint(greeting)\n\n# trying to remember how to split up large nums in python for readability\nmy_bank_account = 1_000_000 \nprint(my_bank_account)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World\n1000000\n```\n:::\n:::\n\n\n## Chapter 4: Control Flow\n> ***iterable***: Any object which has the potential to sequentially yield items\nper-iteration. e.g. container types (`[]`, `()`, `{}`)\n\n- Interesting, you can have a `for/else` where the `else` only gets executed if\nthe for loop doesn't exit early from a `break` statement. (very uncommon to do\nthis and can be replaced by a simple `if` statement after the `for` loop)\n- Exceptions can be raised which will modify the control flow of the program.\nExceptions can be caught using an exception handler `try` `except` `else` `finally`.\n- Python now has `match`\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ncoordinate = (0, 1)\n\nmatch coordinate:\n  case (x, 0): # x here means it can be any value\n    print(f\"coordinate is on the y axis, x={x}\")\n  case (0, y): # y here means it can be any value\n    print(f\"coordinate is on the x axis, y={y}\")\n  case _: # _ here is a catch all if it doesn't match any above patterns\n    print(f\"coordinate is on neither axis\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncoordinate is on the x axis, y=1\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}