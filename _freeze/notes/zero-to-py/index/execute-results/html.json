{
  "hash": "1068286d12d63f04bca0c36f5d4f4b46",
  "result": {
    "markdown": "---\ntitle: Zero to Py\ndescription: 'My notes on [Zero to Py](https://leanpub.com/zero-to-py) by Michael Green.'\nauthor: Tyler Hillery\ndate: '2023-12-19'\nimage: ./zero_to_py.png\nfilters:\n  - social-share\nshare:\n  permalink: 'https://tylerhillery.com/notes/zero-to-py/'\n  description: null\n  twitter: true\n  facebook: false\n  reddit: true\n  stumble: false\n  tumblr: false\n  linkedin: true\n  email: true\n  mastodon: true\ncategories:\n  - Technical Books\nexecute:\n  echo: true\n  error: true\n---\n\n------------------------------------------------------------------------\n\n# Part 1: A Whirlwind Tour\n\n## Chapter 0: System Setup\n\nSkipping this section as I have a working instance of python install and feel comfortable using it.\n\n## Chapter 1: Fundamental Data Types\n\n### Variables\n\nTo reference a given value in python you do so by assigning values to variables using the ***assignment operator =***. Variables are references to values and the data type of the var is the determined by the value it is assigned to.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nx = \"Hello World!\"\nprint(x)\nprint(type(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\n<class 'str'>\n```\n:::\n:::\n\n\n#### Variable Naming Rules\n- Can only contain letters, numbers and underscores no specials characters such\nas `!, @, #, $`\n- Must begin with a letter or underscore \n- Names are case-sensitive so `x` is different than `X`\n- Python has some reserved words that cannot be used for names such as `False`,\n`True`, `None` \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# get the full list of reserved key words \nprint(__import__(\"keyword\").kwlist)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n:::\n:::\n\n\nIn python there is no concept of *constants* meaning that variables can be reassigned\nwhenever changing the value they reference. A common naming convention for vars\nthat are suppose to be constant is to name the var in all caps `PI = 3.14`\n  \n> ***Strongly Typed Language***: Operations which you can do on variables are \ndependent on the variable's type. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nx = list()\ny = int()\nx + y\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: can only concatenate list (not \"int\") to list\n```\n:::\n:::\n\n\n> ***Primitive Data Types***: also referred to as scalar data types, represent\na single value and are indivisible. Examples include `bool`, `int`, `float`.\n\n> ***Container Data Types***: also known as non-scalar data types, represent\nmultiple values, and are divisible. Examples include `list`, `tuple`, `set`, `dict`.\n\n`str` is a special data type that has properties of both primitive and container\ndata types. \n\n> ***Mutability***: refers to the ability to be able to modify the value after \nthey are created. \n\nFor example, a `list` in python is a mutable data type where you add, remove or\nchange elements in a list after it is created. On the other hand a `tuple` is an\n***immutable*** data type, so you cannot modify anything about it after it is created.\n\n`tuple` immutable ordered collection of items `(1, 2, 3)`\n\n`list` mutable order collection of items `[1, 2, 3]` \n\n`set` mutable unordered collection of unique items `{1, 2, 3}`. You can use `frozenset(my_set)`\nto create a immutable set. \n\n### Objects\n\nEverything in python is an object, which means that each element in the language\nis an ***instance*** of a specific ***class**. This includes built in data types\nsuch as `str`, `int`, `list`. \n\n> When a variable is assigned a value in Python, that value is a reference to an\nobject in memory. This reason for this is because the standard implementation of\nPython is built in C-based infrastructure, where the basic unit of memory that\nholds the value of a python object is a C structure called a `PyObject*`. This \n`struct` contains information about the object's type, its reference count, and\nthe actual value. `PyObject*` is a pointer to `PyObject` and it can be used as an \nopaque handle to the python object, allowing the implementation to abstract the\ndetails of these objects and providing python developers a consistent way to\ninteract with any kind of python object, regardless of its type. \n\nEach object in python has its own unique id assigned to it when created. You can\nuse the built in id() function to find out what the id is for a particular object\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nx = 42\ny = 42 \nprint(id(x))\nprint(id(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n140630089565712\n140630089565712\n```\n:::\n:::\n\n\nThis is interesting, I thought these two values would have the same id. I then \nread the next paragraph which calls out specific values in Python that are\n***singletons*** meaning there will only ever be a single instance of this object.\nThe integers `-5` through `256` are singletons along with `None`, `True`, `False`.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nx = 257\ny = 257\nprint(id(x))\nprint(id(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n140629019118608\n140629019124944\n```\n:::\n:::\n\n\n#### References to Objects\nIn python, variables are references to objects meaning when you create a \nvariable and assign a value to it, the variable does not store the value directly,\ninstead stores a reference to the object that contains that value. It is important\nto note when working with immutable data types if you assign the value through a\nsecond variable both variables reference the same mutable object in memory. \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nx = 257\ny = x\nx = 300\nprint(x)\nprint(y)\n\nx = {}\ny = x \ny[\"fizz\"] = \"buzz\"\nprint(x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n300\n257\n{'fizz': 'buzz'}\n{'fizz': 'buzz'}\n```\n:::\n:::\n\n\n## Chapter 2: Operators\n>***Operators***: Special symbols in Python that carry out various operations.\n\n>***Operand***: The value a given operator operates on. For example: `4 + 5 = 9`\n`4` and `5` would be the operands.\n\nPython supports various types of operators: arithmetic, assignment, comparison,\nlogical, membership, bitwise, and identity.\n\n### Arithmetic \n- Used to perform mathematical operations. \n- The order of these operators follow the same rules in math PEMDAS.\n  - It is recommended though to use parentheses to make the code more readable.\n\nThe most common arithmetic operators:\n\n- `+`  addition \n- `-`  subtraction \n- `*`  multiplication\n- `/`  division\n- `//` floor division\n- `%`  modulation \n- `**` exponentiation  \n\n- Python unpacking operators unpack a sequence into multiple arguments\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nmy_tuple = (1,2)\n\nprint([0, *my_tuple, 3, 4])\n\ndict_one = {\"fizz\": \"buzz\"}\ndict_two = {\"foo\": \"bar\"}\nprint({**dict_one, **dict_two})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 2, 3, 4]\n{'fizz': 'buzz', 'foo': 'bar'}\n```\n:::\n:::\n\n\n- Falsy objects: `False`, `None`, `0`, `0.0`, Empty collections i.e. `[]`, `()`,\n`{}`, `set()`\n\n- The identity operator is used to compare the memory address of two objects to\ndetermine if they are same object or not:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nx = 42\ny = 42 \nprint(x is y)\n\nx = 500\ny = 500\nprint(x is y)\n\ny = x\nprint(x is y)\n\nx = [1,2,3]\ny = [1,2,3]\nprint(x is y) # better to use == to see they contain the same values\n\ny = x \nprint(x is y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nTrue\nFalse\nTrue\n```\n:::\n:::\n\n\n## Chapter 3: Lexical Structure \n> ***Lexical Structure***: The smallest units of code that the language is made\nup of, and the rules for combining these units into larger structures. In other\nwords, it is the set of rules that define the syntax and grammar of the language\nand they determine how programs written by developers will be interpreted.\n\n### Line Structure\n- Each logic line is represented by a `NEWLINE` token.\n- A logical line is created by combining one or more \"physical\" lines (the lines\nin a file you create by hitting the \"enter\" key.)\n- Two or more physical lines in python can be joined into a single logical line\nusing the backslash character `\\`\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ngreeting =  \"Hello \" \\\n            \"World\"\nprint(greeting)\n\n# trying to remember how to split up large nums in python for readability\nmy_bank_account = 1_000_000 \nprint(my_bank_account)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World\n1000000\n```\n:::\n:::\n\n\n## Chapter 4: Control Flow\n> ***iterable***: Any object which has the potential to sequentially yield items\nper-iteration. e.g. container types (`[]`, `()`, `{}`)\n\n- Interesting, you can have a `for/else` where the `else` only gets executed if\nthe for loop doesn't exit early from a `break` statement. (very uncommon to do\nthis and can be replaced by a simple `if` statement after the `for` loop)\n- Exceptions can be raised which will modify the control flow of the program.\nExceptions can be caught using an exception handler `try` `except` `else` `finally`.\n- Python now has `match`\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ncoordinate = (0, 1)\n\nmatch coordinate:\n  case (x, 0): # x here means it can be any value\n    print(f\"coordinate is on the y axis, x={x}\")\n  case (0, y): # y here means it can be any value\n    print(f\"coordinate is on the x axis, y={y}\")\n  case _: # _ here is a catch all if it doesn't match any above patterns\n    print(f\"coordinate is on neither axis\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncoordinate is on the x axis, y=1\n```\n:::\n:::\n\n\n- Interesting to learn about how match works with array types and how you can use\nunpacking \n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nlocation = {\n  \"city\": \"Scottsdale\",\n  \"state\": \"Arizona\",\n  \"country\": \"US\"\n}\n\nmatch location:\n  case {\"country\": \"US\", **rest}:\n    print(f\"The city {rest['city']}, {rest['state']} is in the US.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe city Scottsdale, Arizona is in the US.\n```\n:::\n:::\n\n\n- Matching based on types and values\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nitem = 1\nmatch item:\n  case int(0 | -1):\n    print(f\"{item} is either 0 or -1\")\n  case int():\n    print(f\"{item} is an int, not zero or -1\")\n  case _:\n    print(\"This is a catch all\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 is an int, not zero or -1\n```\n:::\n:::\n\n\n> ***guards***: Additional conditions for pattern matching can be included with\nguard statements. Is an `if` statement contained in the case which checks the\ntruthiness of an expression. `case (0, y) if y == 1` \n\n- The ***pipe*** operator can be use to match multiple patterns `|`\n\n## Chapter 5: Functions\n- ***Function Signature*** is the combination of the function's name and its\ninput parameters.\n- ***Positional Argument*** is a function argument which is assigned a name in\naccordance to the order which the names are defined in the function signature.\n- ***Keyword Argument*** is an argument which is explicitly assigned to a specific\nname using `key=value`.\n- Positional arguments must be listed first before keyword arguments.\n- When assigning default values to a function it is recommended not to use a\nmutable data type because the same object is used in every function call which\neffectively creates shared state across all function calls.\n- ***Local Scope*** or ***namespace*** is best explain by an example where variables\nthat are defined in a function block are only accessible within that function \nblock and **can't** be referred to outside of the block. The more formal definition\nis *the space where a given variable name is assigned*.\n- Block scopes can be nested. Any nested block scope can read variables from scopes\nwhich enclose the nested scope.\n- ***LEGB*** rule stands for Local, Enclosing, Global and Build-In. This is the \norder the interpreter searches for a variable reference in a nested rule for searching\nscopes.\n- ***Closures** are functions which have access to variables in an enclosing scope\neven when the function is invoked outside that scope. This allows the function to\n\"remember\" the values of variables from its enclosing scope, and to continue to\naccess them, even after the enclosing scope has exited. This is useful for callbacks,\ndecorators, and encapsulating state.\n\n::: {.callout-important appearance=\"default\" collapse=false title=\"TODO\"}\nClosures are not really clicking for me. Come back and spend some more time\nunderstanding them.\n:::\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef outer_function(message):\n  def inner_function():\n    print(message)\n  return inner_function # what why would I return a function?\n\nmy_closure = outer_function(\"Hello\")\nmy_closure()\n\n# I really do not understand this pattern and why you would do something like this\ndef make_counter():\n  count = 0\n  def counter():\n    nonlocal count\n    count += 1 \n    return count\n  return counter\n\nmy_counter = make_counter()\nprint(my_counter())\nprint(my_counter())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\n1\n2\n```\n:::\n:::\n\n\n- Closures are ultimately a mechanism for exposing functionality without (easily)\nexposing state.\n- ***Decorator*** takes the original function as an argument and returns a new\nfunction that will replace the original function. They are a way to modify the\nbehavior of an object by wrapping it within a function. \n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndef my_decorator(fn):\n  def wrapper():\n    print(\"Entering the function...\")\n    fn()\n    print(\"Exiting the function...\")\n\n  return wrapper\n\n@my_decorator\ndef my_function():\n  print(\"Inside the function...\")\n\nmy_function()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEntering the function...\nInside the function...\nExiting the function...\n```\n:::\n:::\n\n\n- Decorators are typically 2 or 3 functions deep. Instances of 3-deep functions\nallow you to configure the context of the decorator `@my_decorator(\"this\")` by wrapping\nthe decorator in another function (a closure) and returning the decorator function.\n\n# Rest Of Book\nI ended up reading the rest of the book while I was traveling for the holidays\nso I didn't really have a good way to take notes. Here are some highlights I made\nin Kindle while reading. \n\n> ***Polymorphism***: Feature of object oriented programming that allows objects \nof different classes to be treated as objects of a common superclass... Python is\na dynamically-typed language, which allows for a more flexible approach to Polymorphism,\nknow as \"*duck typing*\" which is based on the idea of \"if it quacks like a duck, it's a duck.\"\n\n- I am not a fan of explaining duck typing with that quote I much prefer the explaination\nthe author gave in the next paragraph\n\n> In other words, the type of the object is irrelevant to the execution of your\nprogram, so long as you can operate on an object through an expected interface, \nyour code will execute.\n\n> The `str.casefold()` method is a more powerful version of the str.lower() method\nthat is specifically designed for case-insensitive string comparisons.\n\n- I was not aware of `str.casefold()`!\n\n- The `__main__.py` will run when you use `python -m my_package`. This must be how\nvenv works e.g. `python -m venv .venv` \n\n- Multithreading is best used for IO-bound and high-level structured network code,\nwhile multiprocessing is used for CPU-bound and low-level code. \n\n> ***Thread***: Is a separate execution flow that runs in parallel with the main \nprogram. Threads share the same memory space as the same program, which allows \nthem to access and share data.\n\n- Threads use a preemptive task scheduling model, where the interpreter schedules\nand switches between threads. \n\n- The interpreter can interrupt a running thread at any time, in order to give \nanother thread to chance to run. Python use a ***Global Interpreter Lock*** to \nachieve this: only the thread which has acquired the GIL may execute. \n\n> ***Process***: Is a separate execution environment, with its own memory space \nand Python interpreter. This allows the ability to take advantage of multiple cores\non a machine, and to work around the GIL that prevents multiple threads from executing\nPython code simultaneously. \n\n- Processes run in their own execution environment which means its difficult to \nshare data between them. You have to establish an interprocess communication, \nusing IPC mechanisms to send and receive data.\n\n- `asyncio` library is a redesign how to use threading in python \nto handle I/O and network related tasks. One of the differences is `asyncio` relies\non ***cooperative task switching*** paradigm where tasks voluntarily yield control \nto the scheduler. Each tasks is responsible for releasing control back to the scheduler.\n\n> ***coroutines***: Tasks in the `asnycio` library which use an `await` keyword \nto yield control to the event loop. The event loop schedules the execution of \ncoroutines and switches between them based on their current states and the \navailability of resources. \n\n- Cooperative task switching is more efficient and less error-prone than preemptive \ntask switching, because it allows tasks to run for as they need without interruption.\nThe downside is it requires more explicit coordination between tasks, and it can \nlead to issues such as **deadlocks** and **livelocks** if not implemented correctly. \nPreemptive task switching can be more complex to implement and it can lead to race \nconditions and other synchronization issues, but it can also prevent tasks from \nmonopolizing resources.\n\n> ***Profiling***: The process of measuring the performance of your code to help \nidentify bottlenecks.\n\n# Summary \nZero to Py was good read and it felt like a more digestible way to read \nthrough the python documentation. Some areas that I really like that I was less\nfamiliar with were: pattern matching, type hinting, multithreading, multiprocessing,\nasync and how to build python c extensions. Without a doubt I will be referencing \nthis book in the future. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}