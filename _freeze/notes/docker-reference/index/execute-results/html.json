{
  "hash": "8dfa47a110ce7730c71bba9110aff070",
  "result": {
    "markdown": "---\ntitle: Docker Reference Notes\ndescription: Reference notes on Docker.\nauthor: Tyler Hillery\ndate: '2024-01-27'\nimage: ./docker.png\nfilters:\n  - social-share\nshare:\n  permalink: 'https://tylerhillery.com/notes/docker-reference/'\n  description: null\n  twitter: true\n  facebook: false\n  reddit: true\n  stumble: false\n  tumblr: false\n  linkedin: true\n  email: true\n  mastodon: true\ncategories:\n  - References\n  - In Progress\nexecute:\n  echo: true\n  error: true\n---\n\n------------------------------------------------------------------------\n\n# Relevant Links\n- [docker docs](https://docs.docker.com/)\n- [dockerhub](https://hub.docker.com/)\n\n# Notes \n\n- OS is made of main components:\n  - Applications Layer\n  - Kernel\n\n- Docker only virtualizes the applications layer and uses the host's OS kernel\n\n- VM virtualizes the applications layer and the OS kernel\n\n- Docker images are in the MBs opposed to VMs are couple of GBs *usually*\n\n- You can't run a linux based image on a windows host because the windows kernel can't run linux applications.\n\n- You can get around this by downloading Docker Desktop which runs a **Hypervisor layer** with a lightweight Linux distro \n\n- The **Hypervisor** controls access to physical resources to run multiple VMs on one host machines\n\n- Docker containers runs on the Docker Engine\n\n- The ***docker image*** is an executable application artifact. I like to think of it as the blueprint. It contains\n  - Application: e.g. python app\n  - Services: python interrupter, pip etc.\n  - OS layer: linux\n\n- I like to think of the ***docker container*** as a running instance of an image\n\n- Containers can be impacted by **noisy neighbors**\n\n- High level of Docker Architecture\n  - Docker Host\n    - Docker Daemon (dockerd)\n    - Containers\n    - Images\n  - Docker Client\n    - Command Line\n    - Docker Desktop\n  - Registry\n    - Repositories\n\n- A **writable layer** allows' container storage i.e. local storage in the container\n  - Each container has its own unique writable layer. \n  - Only exists for the lifecycle of the container, they don't persist. \n  - Uses the **union filesystem** which does have a performance hit & they are tightly coupled with the HOST\n  - Allows files and directories from separate file systems to be overlaid - forming a \"single\" file system.\n\n- Types of container storage\n  - `tmpfs` is another type of storage with the following characteristics:\n    - Fast host memory\n    - Not Persistent\n    - Can't be shared between containers\n    - Temp or sensitive files\n  - Host file system \n    - Bind mounts to map host (or remote) folders to a container folder\n    - Allows other containers to access the storage\n    - Rely on host folder structure - it's not managed by docker\n  - Volumes\n    - Similar to host file system but storage is managed by docker\n    - Outside the lifecycle of the container \n    - Can be moved between containers\n\n- Images are a collection of file system layers \n  - Layers can be reused and help avoid unnecessary uploads and downloads \n\n- There are docker registers where you can download these docker images from. The most popular one is [dockerhub](https://hub.docker.com/)\n\n- docker images have different versions of images, with a special one called `latest`\n\n- You don't need to pull the image first, if you use `docker run` it will pull it first if you don't have the image\n\n- When binding container port to host port it's best practice to use the same port # if possible\n\n- `docker run` will create a new container each time \n\n- In the cli commands container id can be swapped with container name\n\n- Registry vs Repository\n  - Registry: A service provider storage, a collection of repositories e.g. Docker Hub is a registry \n  - Repository: Collection of related images with same name but different versions\n\n- To create your own image, you can create a `Dockerfile`\n  - The Dockerfile starts with the base image name you want to start `FROM` e.g. node:19-alpine \n  - `RUN` command will allow you to run command line commands e.g. `npm install`\n  - `COPY` command allows you to copy files from host machine into the container e.g. `COPY package.json /app/` `COPY src /app/`\n  - `ADD` similar to COPY but can add from a remote URL & do extraction etc (e.g. *application/web files*)\n  - `WORKDIR` sets the working directory for all commands after\n  - `CMD` instruction to be executed when a Docker container starts\n    - Only one `CMD` command per Dockerfile\n  - `ENTRYPOINT` similar to CMD but can't be overridden via docker run parameters\n  - `EXPOSE` informs docker what port container app is running on (metadata only! - no network configuration)\n\n- Docker Container Networking\n  - Host networking\n    - containers share the hosts network\n    - can be problematic when containers use same port\n    - don't get to choose the port mapping \n  - Bridge networking\n    - Containers connect to a bridge network\n    - Each container gets a private IP\n    - Each container can use the same port as the IP is unique\n    - Any containers on the same bridge network can communicate with each other\n    - Container ports on accessible until they are published `host:container`\n\n# Common commands \n\n- `docker images` lists all images you have on your machine\n\n- `docker ps` list running containers\n  -`a` will list the non running containers as well \n\n- `docker pull {name}:{tag}` to pull an image from a registry\n  \n- `docker run {name}:{tag}` to create container from image\n  - `-d` for detach so it runs in the background\n  - `-p {HOST_PORT}:{CONTAINER_PORT}` to expose the container post to host\n  - `--name {CONTAINER NAME}` to name your containers, otherwise the name is randomly generated\n  - `-e` to set environment variables\n\n- `docker stop {container id}` to stop a running container\n\n- `docker restart {container id}` to stop and start container\n\n- `docker logs {container id}` to list the logs of the container. This is helpful in detach mode because the logs aren't shown \n\n- `docker container prune` to delete all non running containers\n\n- `docker rm {container name or id}` to remove a docker container\n  - `-f` or `--force`` to forcefully delete a running container\n\n- `docker build path/to/Dockerfile/dir` to build an image from a Dockerfile \n  - `-t {image name}:{version}` to give Dockerfile a name and tag\n\n- `docker inspect {image name or id}` to get metadata about the image \n\n- `docker exec -it {container name or id}` to run commands in the container\n  - `sh` is common command to start a shell in container or `/bin/bash`\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}